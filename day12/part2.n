// v0.0.1
import FileIO

let abs = (i: int) -> int {
    if i < 0 {
        return -i
    }
    return i
}


let enumerate = [t, a] (l: list[t], default: t) -> list[(int, t)] {
    return range(0, l.len(), 1).filterMap((i: int) -> maybe[(int, t)] {
        return yes((i, l[i] | default))
    })
}

// We be doin a little bit of c++
let mut traverse = (p: str, links: map[str, list[str]], smallPoints: map[str, int]) -> int {
    return 1
}

traverse = (p: str, links: map[str, list[str]], smallPoints: map[str, int]) -> int {
    let mut paths = 0
    for (point in (links[p] | [])) {
        if p == "start" {
            print((paths, point))
        } else {
            print((p, point, smallPoints))
        }
        if point == "end" {
            paths += 1
            continue
        }
        if point ~= "start" && (point[0] | \{ }).charCode() > 96 && (point[0] | \{ }).charCode() < 123 && smallPoints[point] == none {
            continue
        }
        paths += traverse(point, links, mapFrom((smallPoints |> entries).filterMap(((po, i): (str, int)) -> maybe[(str, int)] {
            return if point == po && (i - 1) == 0 {
                none
            } else if point == po {
                yes((po, i - 1))
            } else {
                yes((po, i))
            }
        })))
    }
    return paths
}

let main = () -> cmd[()] {
    let possibleValues = FileIO.read("input.txt")!
    if let yes(values) = possibleValues {
        let mut points: list[str] = []
        let mut smallPoints: list[str] = []
        // Process values into array
        let _ = values.strip().split(\n).filterMap((v:str) -> maybe[()] {
            v.strip().split(\{-}).filterMap((val:str) -> maybe[()] {
                if ~(val in points) && val ~= "end" {
                    points = points.append(val)
                    if val ~= "start" && (val[0] | \{ }).charCode() > 96 && (val[0] | \{ }).charCode() < 123 {
                        smallPoints = smallPoints.append(val)
                    }
                }
                return none
            })
            return none
        })

        let mut links: list[(str, list[str])] = []

        for (point in points) {
            let mut l: list[str] = []
            let _ = values.strip().split(\n).filterMap((v:str) -> maybe[()] {
                if let [beg, end] = v.strip().split(\{-}) {
                    if point == beg && end ~= "start" {
                        l = l.append(end)
                    }
                    if point == end && beg ~= "start" {
                        l = l.append(beg)
                    }
                }
                return none
            })
            links = links.append((point, l))
        }
        
        // We be doing a bit of filtering

        print(links)
        
        print(traverse("start", mapFrom(links), mapFrom(smallPoints.filterMap((v: str) -> maybe[(str, int)] {
            return yes((v, 2))
        }))))
    }
    else {
        print("Input file not found")
    }
}

let pub out = main()